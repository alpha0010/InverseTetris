// Generated by CoffeeScript 1.4.0
(function() {
  var InverseTetris,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  InverseTetris = (function() {

    InverseTetris.prototype.currentBoard = null;

    InverseTetris.prototype.cellSize = 25;

    InverseTetris.prototype.numberOfRows = 20;

    InverseTetris.prototype.numberOfColumns = 10;

    InverseTetris.prototype.tickLength = 175;

    InverseTetris.prototype.aiTickLength = 15;

    InverseTetris.prototype.drawingContext = null;

    InverseTetris.prototype.pieces = null;

    InverseTetris.prototype.fallingBlock = null;

    InverseTetris.prototype.aiController = null;

    function InverseTetris(aiModule) {
      this.aiTick = __bind(this.aiTick, this);

      this.tick = __bind(this.tick, this);

      var canvas, h, maxCellSize, w;
      w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      maxCellSize = Math.min((w - 20) / this.numberOfColumns - 1, (h - 120) / this.numberOfRows - 1);
      if (maxCellSize > this.cellSize) {
        this.cellSize = Math.floor((maxCellSize + this.cellSize) / 2);
      } else {
        this.cellSize = Math.floor(maxCellSize);
      }
      canvas = document.getElementById("gameBoard");
      canvas.width = (this.cellSize + 1) * this.numberOfColumns + 1;
      canvas.height = (this.cellSize + 1) * this.numberOfRows + 1;
      this.drawingContext = canvas.getContext("2d");
      this.initPieces();
      this.initBoard();
      this.aiController = aiModule;
      this.tick();
    }

    InverseTetris.prototype.initPieces = function() {
      return this.pieces = [[[0, 255, 255], 2, [1, 1, 1, 1]], [[0, 0, 255], 4, [1, 1, 1], [0, 0, 1]], [[255, 165, 0], 4, [1, 1, 1], [1, 0, 0]], [[255, 255, 0], 1, [1, 1], [1, 1]], [[128, 255, 0], 2, [0, 1, 1], [1, 1, 0]], [[128, 0, 128], 4, [1, 1, 1], [0, 1, 0]], [[255, 0, 255], 2, [1, 1, 0], [0, 1, 1]]];
    };

    InverseTetris.prototype.initBoard = function() {
      var cell, column, row, _i, _j, _ref, _ref1;
      this.currentBoard = [];
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        this.currentBoard[row] = [];
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          cell = this.createCell();
          this.currentBoard[row][column] = cell;
        }
      }
    };

    InverseTetris.prototype.createCell = function() {
      return {
        isFull: false,
        fillStyle: null
      };
    };

    InverseTetris.prototype.rotateArray = function(theArray) {
      var column, outArray, row, _i, _j, _ref, _ref1;
      outArray = [];
      for (row = _i = 0, _ref = theArray.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = theArray[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (row === 0) {
            outArray[column] = [];
          }
          outArray[column][row] = theArray[theArray.length - row - 1][column];
        }
      }
      return outArray;
    };

    InverseTetris.prototype.tick = function() {
      if (this.fallingBlock === null) {
        this.fallingBlock = this.createFallingBlock(this.pieces[Math.floor(Math.random() * 7)]);
      }
      if (this.blockIntersects(this.fallingBlock.row + 1, this.fallingBlock.column)) {
        if (this.fallingBlock.row === -1) {
          return;
        }
        this.applyBlock();
        this.fallingBlock = null;
      } else {
        this.fallingBlock.row += 1;
      }
      this.drawGrid();
      setTimeout(this.tick, this.tickLength);
      return setTimeout(this.aiTick, this.aiTickLength);
    };

    InverseTetris.prototype.aiTick = function() {
      var move;
      if (this.fallingBlock === null) {
        return;
      }
      move = this.aiController.chooseMove(this.currentBoard, this.fallingBlock, 1);
      switch (move) {
        case 1:
          this.moveLeft();
          break;
        case 2:
          this.moveRight();
          break;
        case 3:
          this.rotateCCW();
          break;
        case 4:
          this.rotateCW();
          break;
        default:
          return;
      }
      return setTimeout(this.aiTick, this.aiTickLength);
    };

    InverseTetris.prototype.blockIntersects = function(row, column) {
      var shapeColumn, shapeRow, _i, _j, _ref, _ref1;
      for (shapeRow = _i = 0, _ref = this.fallingBlock.geometry.length; 0 <= _ref ? _i < _ref : _i > _ref; shapeRow = 0 <= _ref ? ++_i : --_i) {
        if (row + shapeRow < 0 || row + shapeRow >= this.numberOfRows) {
          return true;
        }
        for (shapeColumn = _j = 0, _ref1 = this.fallingBlock.geometry[shapeRow].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; shapeColumn = 0 <= _ref1 ? ++_j : --_j) {
          if (column + shapeColumn < 0 || column + shapeColumn >= this.numberOfColumns) {
            return true;
          }
          if (this.fallingBlock.geometry[shapeRow][shapeColumn] === 1 && this.currentBoard[row + shapeRow][column + shapeColumn].isFull) {
            return true;
          }
        }
      }
      return false;
    };

    InverseTetris.prototype.createFallingBlock = function(shape) {
      return {
        row: -1,
        column: Math.floor((this.numberOfColumns - shape[2].length) / 2),
        fillStyle: "rgb(" + shape[0][0] + "," + shape[0][1] + "," + shape[0][2] + ")",
        orientations: shape[1],
        geometry: shape.slice(2)
      };
    };

    InverseTetris.prototype.applyBlock = function() {
      var cell, column, row, shape, _i, _j, _ref, _ref1;
      shape = this.fallingBlock.geometry;
      for (row = _i = 0, _ref = shape.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = shape[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (shape[row][column] === 1) {
            cell = this.currentBoard[row + this.fallingBlock.row][column + this.fallingBlock.column];
            cell.isFull = true;
            cell.fillStyle = this.fallingBlock.fillStyle;
          }
        }
      }
      return this.checkLines();
    };

    InverseTetris.prototype.checkLines = function() {
      var row, _i, _ref;
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        if (this.arrayIsFull(this.currentBoard[row])) {
          this.removeRow(row);
        }
      }
    };

    InverseTetris.prototype.arrayIsFull = function(theArray) {
      var cell, _i, _len;
      for (_i = 0, _len = theArray.length; _i < _len; _i++) {
        cell = theArray[_i];
        if (!cell.isFull) {
          return false;
        }
      }
      return true;
    };

    InverseTetris.prototype.removeRow = function(row) {
      var column, _i, _ref;
      this.currentBoard.splice(row, 1);
      this.currentBoard.splice(0, 0, []);
      for (column = _i = 0, _ref = this.numberOfColumns; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
        this.currentBoard[0][column] = this.createCell();
      }
    };

    InverseTetris.prototype.drawGrid = function() {
      var cell, column, row, shape, shapeColumn, shapeRow, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          this.drawCell(this.currentBoard[row][column], row, column);
        }
      }
      if (this.fallingBlock !== null) {
        cell = this.createCell();
        cell.isFull = true;
        cell.fillStyle = this.fallingBlock.fillStyle;
        shape = this.fallingBlock.geometry;
        for (shapeRow = _k = 0, _ref2 = shape.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; shapeRow = 0 <= _ref2 ? ++_k : --_k) {
          for (shapeColumn = _l = 0, _ref3 = shape[shapeRow].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; shapeColumn = 0 <= _ref3 ? ++_l : --_l) {
            if (shape[shapeRow][shapeColumn] === 1) {
              this.drawCell(cell, this.fallingBlock.row + shapeRow, this.fallingBlock.column + shapeColumn);
            }
          }
        }
      }
    };

    InverseTetris.prototype.drawCell = function(cell, row, column) {
      var backgroundCol, bevelRad, fillStyle, gradient, x, y;
      x = column * (this.cellSize + 1) + 1;
      y = row * (this.cellSize + 1) + 1;
      backgroundCol = "rgb(38,38,38)";
      if (cell.isFull) {
        fillStyle = cell.fillStyle;
      } else {
        fillStyle = backgroundCol;
      }
      this.drawingContext.strokeStyle = "rgb(54,51,40)";
      this.drawingContext.strokeRect(x, y, this.cellSize, this.cellSize);
      this.drawingContext.fillStyle = fillStyle;
      this.drawingContext.fillRect(x, y, this.cellSize, this.cellSize);
      if (cell.isFull) {
        bevelRad = this.cellSize / 4;
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x, y + this.cellSize - bevelRad, x, y + this.cellSize);
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(1, "rgba(0,0,0,0.5)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize, y);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x + this.cellSize - bevelRad, y, x + this.cellSize, y);
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(1, "rgba(0,0,0,0.5)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y);
        this.drawingContext.lineTo(x + this.cellSize, y);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x, y + bevelRad, x, y);
        gradient.addColorStop(0, "rgba(255,255,255,0)");
        gradient.addColorStop(1, "rgba(255,255,255,0.4)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y);
        this.drawingContext.lineTo(x, y + this.cellSize);
        this.drawingContext.lineTo(x + bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x + bevelRad, y, x, y);
        gradient.addColorStop(0, "rgba(255,255,255,0)");
        gradient.addColorStop(1, "rgba(255,255,255,0.4)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        bevelRad = this.cellSize / 6;
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + bevelRad, y);
        this.drawingContext.quadraticCurveTo(x, y, x, y + bevelRad);
        this.drawingContext.lineTo(x, y);
        this.drawingContext.closePath();
        this.drawingContext.fillStyle = backgroundCol;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize - bevelRad, y);
        this.drawingContext.quadraticCurveTo(x + this.cellSize, y, x + this.cellSize, y + bevelRad);
        this.drawingContext.lineTo(x + this.cellSize, y);
        this.drawingContext.closePath();
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y + this.cellSize - bevelRad);
        this.drawingContext.quadraticCurveTo(x, y + this.cellSize, x + bevelRad, y + this.cellSize);
        this.drawingContext.lineTo(x, y + this.cellSize);
        this.drawingContext.closePath();
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize, y + this.cellSize - bevelRad);
        this.drawingContext.quadraticCurveTo(x + this.cellSize, y + this.cellSize, x + this.cellSize - bevelRad, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.closePath();
        return this.drawingContext.fill();
      }
    };

    InverseTetris.prototype.moveLeft = function() {
      if (this.fallingBlock === null || this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column - 1)) {
        return;
      }
      this.fallingBlock.column -= 1;
      return this.drawGrid();
    };

    InverseTetris.prototype.moveRight = function() {
      if (this.fallingBlock === null || this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column + 1)) {
        return;
      }
      this.fallingBlock.column += 1;
      return this.drawGrid();
    };

    InverseTetris.prototype.rotateCCW = function() {
      var oldGeom;
      if (this.fallingBlock === null) {
        return;
      }
      oldGeom = this.fallingBlock.geometry;
      this.fallingBlock.geometry = this.rotateArray(this.rotateArray(this.rotateArray(this.fallingBlock.geometry)));
      if (this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column)) {
        return this.fallingBlock.geometry = oldGeom;
      } else {
        return this.drawGrid();
      }
    };

    InverseTetris.prototype.rotateCW = function() {
      var oldGeom;
      if (this.fallingBlock === null) {
        return;
      }
      oldGeom = this.fallingBlock.geometry;
      this.fallingBlock.geometry = this.rotateArray(this.fallingBlock.geometry);
      if (this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column)) {
        return this.fallingBlock.geometry = oldGeom;
      } else {
        return this.drawGrid();
      }
    };

    return InverseTetris;

  })();

  window.InverseTetris = InverseTetris;

}).call(this);
