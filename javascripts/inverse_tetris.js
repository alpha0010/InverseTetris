// Generated by CoffeeScript 1.4.0
(function() {
  var InverseTetris,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  InverseTetris = (function() {

    InverseTetris.prototype.currentBoard = null;

    InverseTetris.prototype.cellSize = 25;

    InverseTetris.prototype.numberOfRows = 20;

    InverseTetris.prototype.numberOfColumns = 10;

    InverseTetris.prototype.rightBuffer = 5;

    InverseTetris.prototype.bottemBuffer = 4;

    InverseTetris.prototype.tickLength = 175;

    InverseTetris.prototype.aiTickLength = 15;

    InverseTetris.prototype.drawingContext = null;

    InverseTetris.prototype.pieces = null;

    InverseTetris.prototype.fallingBlock = null;

    InverseTetris.prototype.nextBlock = null;

    InverseTetris.prototype.nextBlockIdx = null;

    InverseTetris.prototype.aiController = null;

    InverseTetris.prototype.score = 0;

    InverseTetris.prototype.totalMoves = 0;

    InverseTetris.prototype.rectBounds = null;

    InverseTetris.prototype.selectedShape = -1;

    InverseTetris.prototype.uiBounds = null;

    function InverseTetris(aiModule) {
      this.onEvtKeyPress = __bind(this.onEvtKeyPress, this);

      this.onEvtMouseClick = __bind(this.onEvtMouseClick, this);

      this.onEvtMouseMove = __bind(this.onEvtMouseMove, this);

      this.aiTick = __bind(this.aiTick, this);

      this.tick = __bind(this.tick, this);

      var aiChoices, canvas, h, maxCellSize, piece, w, _i, _len, _ref,
        _this = this;
      w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      maxCellSize = Math.min((w - 20) / (this.numberOfColumns + this.rightBuffer) - 1, (h - 20) / (this.numberOfRows + this.bottemBuffer) - 1);
      if (maxCellSize > this.cellSize) {
        this.cellSize = Math.floor((7 * maxCellSize + this.cellSize) / 8);
      } else {
        this.cellSize = Math.floor(maxCellSize);
      }
      canvas = document.getElementById("gameBoard");
      canvas.width = (this.cellSize + 1) * (this.numberOfColumns + this.rightBuffer) + 1;
      canvas.height = (this.cellSize + 1) * (this.numberOfRows + this.bottemBuffer) + 1;
      this.drawingContext = canvas.getContext("2d");
      this.drawingContext.fillStyle = "rgb(38,38,38)";
      this.drawingContext.strokeStyle = "transparent";
      this.drawingContext.fillRect(0, 0, canvas.width, canvas.height);
      this.initPieces();
      this.initBoard();
      this.nextBlockIdx = Math.floor(Math.random() * 7);
      this.nextBlock = this.createFallingBlock(this.pieces[this.nextBlockIdx]);
      this.initUIBounds();
      this.rectBounds = canvas.getBoundingClientRect();
      canvas.addEventListener("mousemove", function(e) {
        return _this.onEvtMouseMove(e);
      });
      canvas.addEventListener("mouseup", function(e) {
        _this.onEvtMouseMove(e);
        return _this.onEvtMouseClick(e);
      });
      window.addEventListener("keypress", function(e) {
        return _this.onEvtKeyPress(e);
      });
      aiChoices = [];
      _ref = this.pieces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piece = _ref[_i];
        aiChoices.push(this.createFallingBlock(piece));
      }
      aiModule.initBlockChoices(aiChoices);
      this.aiController = aiModule;
      this.tick();
    }

    InverseTetris.prototype.initPieces = function() {
      this.pieces = [[[0, 255, 255], 2, [1, 1, 1, 1]], [[0, 0, 255], 4, [1, 1, 1], [0, 0, 1]], [[255, 165, 0], 4, [1, 1, 1], [1, 0, 0]], [[255, 255, 0], 1, [1, 1], [1, 1]], [[128, 255, 0], 2, [0, 1, 1], [1, 1, 0]], [[128, 0, 128], 4, [1, 1, 1], [0, 1, 0]], [[255, 0, 255], 2, [1, 1, 0], [0, 1, 1]]];
      return this.pieces.ids = "ijlostz";
    };

    InverseTetris.prototype.initBoard = function() {
      var cell, column, row, _i, _j, _ref, _ref1;
      this.currentBoard = [];
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        this.currentBoard[row] = [];
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          cell = this.createCell();
          this.currentBoard[row][column] = cell;
        }
      }
    };

    InverseTetris.prototype.initUIBounds = function() {
      var halfSz, pIdx, _i, _ref;
      this.uiBounds = [];
      halfSz = this.cellSize / 2;
      for (pIdx = _i = 0, _ref = this.pieces.length; 0 <= _ref ? _i < _ref : _i > _ref; pIdx = 0 <= _ref ? ++_i : --_i) {
        this.uiBounds.push({
          x: (1 + 5 * (pIdx % 4)) * (halfSz + 1) + 1,
          y: (2 * this.numberOfRows + (pIdx > 3 ? 3 : 0)) * (halfSz + 1) + 1,
          count: 4
        });
      }
    };

    InverseTetris.prototype.createCell = function() {
      return {
        isFull: false,
        fillStyle: null
      };
    };

    InverseTetris.prototype.rotateArray = function(theArray) {
      var column, outArray, row, _i, _j, _ref, _ref1;
      outArray = [];
      for (row = _i = 0, _ref = theArray.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = theArray[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (row === 0) {
            outArray[column] = [];
          }
          outArray[column][row] = theArray[theArray.length - row - 1][column];
        }
      }
      return outArray;
    };

    InverseTetris.prototype.tick = function() {
      var allEqual, allLessThanTwo, bound, cell, idx, minVal, numFilledCells, row, testVal, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4;
      if (this.fallingBlock === null) {
        if (this.nextBlock === null) {
          if (Math.random() < 0.7) {
            minVal = Number.MAX_VALUE;
            for (idx = _i = 0, _ref = this.uiBounds.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
              if (this.uiBounds[idx].count > 0) {
                testVal = this.aiController.queryDesirability(this.currentBoard, this.createFallingBlock(this.pieces[idx]));
                if (testVal < minVal) {
                  minVal = testVal;
                  this.nextBlockIdx = idx;
                }
              }
            }
          } else {
            this.nextBlockIdx = Math.floor(Math.random() * 7);
            while (this.uiBounds[this.nextBlockIdx].count === 0) {
              this.nextBlockIdx = (this.nextBlockIdx + 1) % 7;
            }
          }
          this.nextBlock = this.createFallingBlock(this.pieces[this.nextBlockIdx]);
        }
        this.fallingBlock = this.nextBlock;
        this.uiBounds[this.nextBlockIdx].count -= 1;
        allLessThanTwo = true;
        allEqual = true;
        _ref1 = this.uiBounds;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          bound = _ref1[_j];
          if (bound.count > 1) {
            allLessThanTwo = false;
          }
          if (bound.count !== this.uiBounds[this.nextBlockIdx].count) {
            allEqual = false;
          }
        }
        if (allEqual) {
          _ref2 = this.uiBounds;
          for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
            bound = _ref2[_k];
            bound.count = 4;
          }
        } else if (allLessThanTwo) {
          _ref3 = this.uiBounds;
          for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
            bound = _ref3[_l];
            bound.count += 2;
          }
        }
        if (this.selectedShape !== -1 && this.uiBounds[this.selectedShape].count <= 0) {
          this.selectedShape = -1;
        }
        this.nextBlockIdx = -1;
        this.nextBlock = null;
        this.drawNextBlock();
        this.drawUI();
        this.tickLength = 175;
      }
      if (this.blockIntersects(this.fallingBlock.row + 1, this.fallingBlock.column)) {
        if (this.fallingBlock.row === -1) {
          return;
        }
        this.applyBlock();
        this.fallingBlock = null;
        numFilledCells = 0;
        _ref4 = this.currentBoard;
        for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
          row = _ref4[_m];
          for (_n = 0, _len4 = row.length; _n < _len4; _n++) {
            cell = row[_n];
            if (cell.isFull) {
              numFilledCells += 1;
            }
          }
        }
        this.totalMoves += 1;
        this.score += Math.floor(Math.pow(numFilledCells, 0.6) * 4) / 4;
      } else {
        this.fallingBlock.row += 1;
      }
      this.drawGrid();
      setTimeout(this.tick, this.tickLength);
      return setTimeout(this.aiTick, this.aiTickLength);
    };

    InverseTetris.prototype.aiTick = function() {
      var move;
      if (this.fallingBlock === null) {
        return;
      }
      move = this.aiController.chooseMove(this.currentBoard, this.fallingBlock);
      switch (move) {
        case 1:
          this.moveLeft();
          break;
        case 2:
          this.moveRight();
          break;
        case 3:
          this.rotateCCW();
          break;
        case 4:
          this.rotateCW();
          break;
        default:
          this.tickLength = Math.max(64, 175 - this.totalMoves);
          return;
      }
      this.tickLength = 175;
      return setTimeout(this.aiTick, this.aiTickLength);
    };

    InverseTetris.prototype.onEvtMouseMove = function(evt) {
      var cIdx, corner, xPos, yPos, _i, _ref;
      xPos = evt.clientX - this.rectBounds.left;
      yPos = evt.clientY - this.rectBounds.top;
      for (cIdx = _i = 0, _ref = this.uiBounds.length; 0 <= _ref ? _i < _ref : _i > _ref; cIdx = 0 <= _ref ? ++_i : --_i) {
        corner = this.uiBounds[cIdx];
        if (xPos > corner.x && xPos < corner.x + 2 * this.cellSize && yPos > corner.y && yPos < corner.y + this.cellSize) {
          if (this.uiBounds[cIdx].count <= 0) {
            cIdx = -1;
          }
          if (this.selectedShape !== cIdx) {
            this.selectedShape = cIdx;
            this.drawUI();
          }
          return;
        }
      }
      if (this.selectedShape !== -1) {
        this.selectedShape = -1;
        this.drawUI();
      }
    };

    InverseTetris.prototype.onEvtMouseClick = function(evt) {
      if (this.selectedShape !== -1) {
        this.nextBlock = this.createFallingBlock(this.pieces[this.selectedShape]);
        this.nextBlockIdx = this.selectedShape;
        this.drawNextBlock();
      }
    };

    InverseTetris.prototype.onEvtKeyPress = function(evt) {
      var evtKey, shapeIdx;
      evtKey = null;
      if (evt.which === null) {
        evtKey = String.fromCharCode(evt.keyCode);
      } else if (evt.which !== 0 && evt.charCode !== 0) {
        evtKey = String.fromCharCode(evt.which);
      }
      if (evtKey !== null) {
        shapeIdx = this.pieces.ids.search(evtKey);
        if (shapeIdx !== -1 && this.uiBounds[shapeIdx].count > 0 && shapeIdx !== this.nextBlockIdx) {
          this.nextBlock = this.createFallingBlock(this.pieces[shapeIdx]);
          this.nextBlockIdx = shapeIdx;
          this.drawNextBlock();
        }
      }
    };

    InverseTetris.prototype.blockIntersects = function(row, column) {
      var shapeColumn, shapeRow, _i, _j, _ref, _ref1;
      for (shapeRow = _i = 0, _ref = this.fallingBlock.geometry.length; 0 <= _ref ? _i < _ref : _i > _ref; shapeRow = 0 <= _ref ? ++_i : --_i) {
        if (row + shapeRow < 0 || row + shapeRow >= this.numberOfRows) {
          return true;
        }
        for (shapeColumn = _j = 0, _ref1 = this.fallingBlock.geometry[shapeRow].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; shapeColumn = 0 <= _ref1 ? ++_j : --_j) {
          if (column + shapeColumn < 0 || column + shapeColumn >= this.numberOfColumns) {
            return true;
          }
          if (this.fallingBlock.geometry[shapeRow][shapeColumn] === 1 && this.currentBoard[row + shapeRow][column + shapeColumn].isFull) {
            return true;
          }
        }
      }
      return false;
    };

    InverseTetris.prototype.createFallingBlock = function(shape) {
      return {
        row: -1,
        column: Math.floor((this.numberOfColumns - shape[2].length) / 2),
        fillStyle: "rgb(" + shape[0][0] + "," + shape[0][1] + "," + shape[0][2] + ")",
        orientations: shape[1],
        geometry: shape.slice(2)
      };
    };

    InverseTetris.prototype.applyBlock = function() {
      var cell, column, row, shape, _i, _j, _ref, _ref1;
      shape = this.fallingBlock.geometry;
      for (row = _i = 0, _ref = shape.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = shape[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (shape[row][column] === 1) {
            cell = this.currentBoard[row + this.fallingBlock.row][column + this.fallingBlock.column];
            cell.isFull = true;
            cell.fillStyle = this.fallingBlock.fillStyle;
          }
        }
      }
      return this.checkLines();
    };

    InverseTetris.prototype.checkLines = function() {
      var row, _i, _ref;
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        if (this.arrayIsFull(this.currentBoard[row])) {
          this.removeRow(row);
        }
      }
    };

    InverseTetris.prototype.arrayIsFull = function(theArray) {
      var cell, _i, _len;
      for (_i = 0, _len = theArray.length; _i < _len; _i++) {
        cell = theArray[_i];
        if (!cell.isFull) {
          return false;
        }
      }
      return true;
    };

    InverseTetris.prototype.removeRow = function(row) {
      var column, _i, _ref;
      this.currentBoard.splice(row, 1);
      this.currentBoard.splice(0, 0, []);
      for (column = _i = 0, _ref = this.numberOfColumns; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
        this.currentBoard[0][column] = this.createCell();
      }
    };

    InverseTetris.prototype.drawGrid = function() {
      var cell, column, row, shape, shapeColumn, shapeRow, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          this.drawCell(this.currentBoard[row][column], row, column);
        }
      }
      if (this.fallingBlock !== null) {
        cell = this.createCell();
        cell.isFull = true;
        cell.fillStyle = this.fallingBlock.fillStyle;
        shape = this.fallingBlock.geometry;
        for (shapeRow = _k = 0, _ref2 = shape.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; shapeRow = 0 <= _ref2 ? ++_k : --_k) {
          for (shapeColumn = _l = 0, _ref3 = shape[shapeRow].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; shapeColumn = 0 <= _ref3 ? ++_l : --_l) {
            if (shape[shapeRow][shapeColumn] === 1) {
              this.drawCell(cell, this.fallingBlock.row + shapeRow, this.fallingBlock.column + shapeColumn);
            }
          }
        }
      }
    };

    InverseTetris.prototype.drawNextBlock = function() {
      var cell, shape, shapeColumn, shapeRow, _i, _j, _ref, _ref1;
      this.drawingContext.fillStyle = "rgb(38,38,38)";
      this.drawingContext.strokeStyle = "transparent";
      this.drawingContext.fillRect(this.numberOfColumns * (this.cellSize + 1) + 1, 0, this.rightBuffer * (this.cellSize + 1), this.numberOfRows * (this.cellSize + 1));
      this.drawScore();
      if (this.nextBlock === null) {
        this.drawingContext.font = "" + this.cellSize + "px Arial";
        this.drawingContext.fillStyle = "white";
        this.drawingContext.fillText("???", (this.numberOfColumns + 1.25) * (this.cellSize + 1), 2.25 * (this.cellSize + 1));
        return;
      }
      cell = this.createCell();
      cell.isFull = true;
      cell.fillStyle = this.nextBlock.fillStyle;
      shape = this.nextBlock.geometry;
      for (shapeRow = _i = 0, _ref = shape.length; 0 <= _ref ? _i < _ref : _i > _ref; shapeRow = 0 <= _ref ? ++_i : --_i) {
        for (shapeColumn = _j = 0, _ref1 = shape[shapeRow].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; shapeColumn = 0 <= _ref1 ? ++_j : --_j) {
          if (shape[shapeRow][shapeColumn] === 1) {
            this.drawCell(cell, 1 + shapeRow, this.numberOfColumns + 1 + shapeColumn);
          }
        }
      }
    };

    InverseTetris.prototype.drawUI = function() {
      var block, cell, oldCellSize, pIdx, shape, shapeColumn, shapeRow, strokeCol, _i, _j, _k, _ref, _ref1, _ref2;
      this.drawingContext.fillStyle = "rgb(38,38,38)";
      this.drawingContext.strokeStyle = "transparent";
      this.drawingContext.fillRect(0, this.numberOfRows * (this.cellSize + 1) + 1, this.numberOfColumns * (this.cellSize + 1), this.bottemBuffer * (this.cellSize + 1));
      oldCellSize = this.cellSize;
      this.cellSize /= 2;
      for (pIdx = _i = 0, _ref = this.pieces.length; 0 <= _ref ? _i < _ref : _i > _ref; pIdx = 0 <= _ref ? ++_i : --_i) {
        block = this.pieces[pIdx];
        cell = this.createCell();
        cell.isFull = true;
        if (this.uiBounds[pIdx].count > 0) {
          cell.fillStyle = "rgb(" + block[0][0] + "," + block[0][1] + "," + block[0][2] + ")";
        } else {
          cell.fillStyle = "gray";
        }
        strokeCol = "transparent";
        if (pIdx === this.selectedShape) {
          strokeCol = "red";
        }
        shape = block.slice(2);
        for (shapeRow = _j = 0, _ref1 = shape.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; shapeRow = 0 <= _ref1 ? ++_j : --_j) {
          for (shapeColumn = _k = 0, _ref2 = shape[shapeRow].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; shapeColumn = 0 <= _ref2 ? ++_k : --_k) {
            if (shape[shapeRow][shapeColumn] === 1) {
              this.drawCell(cell, 2 * this.numberOfRows + shapeRow + (pIdx > 3 ? 3 : 0), 1 + shapeColumn + 5 * (pIdx % 4), strokeCol);
            }
          }
        }
        this.drawingContext.font = "" + this.cellSize + "px Arial";
        this.drawingContext.fillStyle = "white";
        this.drawingContext.fillText(this.uiBounds[pIdx].count, this.uiBounds[pIdx].x, this.uiBounds[pIdx].y - 1);
        this.drawingContext.font = "" + (this.cellSize * 0.9) + "px Arial";
        this.drawingContext.fillStyle = "grey";
        this.drawingContext.fillText("(" + (this.pieces.ids[pIdx].toUpperCase()) + ")", this.uiBounds[pIdx].x + this.cellSize, this.uiBounds[pIdx].y - this.cellSize / 5);
      }
      return this.cellSize = oldCellSize;
    };

    InverseTetris.prototype.drawScore = function() {
      this.drawingContext.font = "" + this.cellSize + "px Arial";
      this.drawingContext.fillStyle = "white";
      this.drawingContext.fillText("Score", (this.numberOfColumns + 0.5) * (this.cellSize + 1), 5 * (this.cellSize + 1));
      if (this.totalMoves > 0) {
        this.drawingContext.fillText(Math.round(1000 * this.score / this.totalMoves), (this.numberOfColumns + 0.5) * (this.cellSize + 1), 6 * (this.cellSize + 1));
      }
      this.drawingContext.fillText("Blocks", (this.numberOfColumns + 0.5) * (this.cellSize + 1), 7.4 * (this.cellSize + 1));
      return this.drawingContext.fillText(this.totalMoves, (this.numberOfColumns + 0.5) * (this.cellSize + 1), 8.4 * (this.cellSize + 1));
    };

    InverseTetris.prototype.drawCell = function(cell, row, column, strokeCol) {
      var backgroundCol, bevelRad, fillStyle, gradient, x, y;
      if (strokeCol == null) {
        strokeCol = "rgb(54,51,40)";
      }
      x = column * (this.cellSize + 1) + 1;
      y = row * (this.cellSize + 1) + 1;
      backgroundCol = "rgb(38,38,38)";
      fillStyle = cell.isFull ? cell.fillStyle : backgroundCol;
      this.drawingContext.strokeStyle = strokeCol;
      this.drawingContext.strokeRect(x, y, this.cellSize, this.cellSize);
      this.drawingContext.fillStyle = fillStyle;
      this.drawingContext.fillRect(x, y, this.cellSize, this.cellSize);
      if (cell.isFull) {
        bevelRad = this.cellSize / 4;
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x, y + this.cellSize - bevelRad, x, y + this.cellSize);
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(1, "rgba(0,0,0,0.5)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize, y);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x + this.cellSize - bevelRad, y, x + this.cellSize, y);
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(1, "rgba(0,0,0,0.5)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y);
        this.drawingContext.lineTo(x + this.cellSize, y);
        this.drawingContext.lineTo(x + this.cellSize - bevelRad, y + bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x, y + bevelRad, x, y);
        gradient.addColorStop(0, "rgba(255,255,255,0)");
        gradient.addColorStop(1, "rgba(255,255,255,0.4)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y);
        this.drawingContext.lineTo(x, y + this.cellSize);
        this.drawingContext.lineTo(x + bevelRad, y + this.cellSize - bevelRad);
        this.drawingContext.lineTo(x + bevelRad, y + bevelRad);
        this.drawingContext.closePath();
        gradient = this.drawingContext.createLinearGradient(x + bevelRad, y, x, y);
        gradient.addColorStop(0, "rgba(255,255,255,0)");
        gradient.addColorStop(1, "rgba(255,255,255,0.4)");
        this.drawingContext.fillStyle = gradient;
        this.drawingContext.fill();
        bevelRad = this.cellSize / 6;
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + bevelRad, y);
        this.drawingContext.quadraticCurveTo(x, y, x, y + bevelRad);
        this.drawingContext.lineTo(x, y);
        this.drawingContext.closePath();
        this.drawingContext.fillStyle = backgroundCol;
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize - bevelRad, y);
        this.drawingContext.quadraticCurveTo(x + this.cellSize, y, x + this.cellSize, y + bevelRad);
        this.drawingContext.lineTo(x + this.cellSize, y);
        this.drawingContext.closePath();
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x, y + this.cellSize - bevelRad);
        this.drawingContext.quadraticCurveTo(x, y + this.cellSize, x + bevelRad, y + this.cellSize);
        this.drawingContext.lineTo(x, y + this.cellSize);
        this.drawingContext.closePath();
        this.drawingContext.fill();
        this.drawingContext.beginPath();
        this.drawingContext.moveTo(x + this.cellSize, y + this.cellSize - bevelRad);
        this.drawingContext.quadraticCurveTo(x + this.cellSize, y + this.cellSize, x + this.cellSize - bevelRad, y + this.cellSize);
        this.drawingContext.lineTo(x + this.cellSize, y + this.cellSize);
        this.drawingContext.closePath();
        return this.drawingContext.fill();
      }
    };

    InverseTetris.prototype.moveLeft = function() {
      if (this.fallingBlock === null || this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column - 1)) {
        return;
      }
      this.fallingBlock.column -= 1;
      return this.drawGrid();
    };

    InverseTetris.prototype.moveRight = function() {
      if (this.fallingBlock === null || this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column + 1)) {
        return;
      }
      this.fallingBlock.column += 1;
      return this.drawGrid();
    };

    InverseTetris.prototype.rotateCCW = function() {
      var oldGeom;
      if (this.fallingBlock === null) {
        return;
      }
      oldGeom = this.fallingBlock.geometry;
      this.fallingBlock.geometry = this.rotateArray(this.rotateArray(this.rotateArray(this.fallingBlock.geometry)));
      if (this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column)) {
        return this.fallingBlock.geometry = oldGeom;
      } else {
        return this.drawGrid();
      }
    };

    InverseTetris.prototype.rotateCW = function() {
      var oldGeom;
      if (this.fallingBlock === null) {
        return;
      }
      oldGeom = this.fallingBlock.geometry;
      this.fallingBlock.geometry = this.rotateArray(this.fallingBlock.geometry);
      if (this.blockIntersects(this.fallingBlock.row, this.fallingBlock.column)) {
        return this.fallingBlock.geometry = oldGeom;
      } else {
        return this.drawGrid();
      }
    };

    return InverseTetris;

  })();

  window.InverseTetris = InverseTetris;

}).call(this);
