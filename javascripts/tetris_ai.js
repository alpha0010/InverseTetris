// Generated by CoffeeScript 1.4.0
(function() {
  var TetrisAI;

  TetrisAI = (function() {

    TetrisAI.prototype.pieces = null;

    TetrisAI.prototype.moveCache = null;

    TetrisAI.prototype.maxDepth = 0;

    function TetrisAI(depth) {
      this.maxDepth = depth;
    }

    TetrisAI.prototype.initBlockChoices = function(blocks) {
      this.pieces = blocks;
      return this.moveCache = {};
    };

    TetrisAI.prototype.chooseMove = function(currentBoard, block) {
      return this.calcMove(this.cloneBoard(currentBoard), block)[0];
    };

    TetrisAI.prototype.queryDesirability = function(currentBoard, block) {
      return this.calcMove(this.cloneBoard(currentBoard), block, this.maxDepth - 1)[1];
    };

    TetrisAI.prototype.calcMove = function(tstBrd, block, depth) {
      var bestMove, minVal, oldGeom, tstBlck, tstVal;
      if (depth == null) {
        depth = 0;
      }
      tstBlck = this.cloneBlock(block);
      minVal = this.scoreMove(tstBrd, tstBlck, depth);
      bestMove = 0;
      tstVal = this.testMoveLeft(tstBrd, tstBlck, depth);
      if (tstVal < minVal) {
        minVal = tstVal;
        bestMove = 1;
      }
      tstBlck.column = block.column;
      tstVal = this.testMoveRight(tstBrd, tstBlck, depth);
      if (tstVal < minVal) {
        minVal = tstVal;
        bestMove = 2;
      }
      if (block.orientations > 1) {
        tstVal = this.testRotateCCW(tstBrd, tstBlck, depth);
        if (tstVal < minVal) {
          minVal = tstVal;
          bestMove = 3;
        }
        if (block.orientations > 2) {
          tstVal = this.testRotateCW(tstBrd, tstBlck, depth);
          if (tstVal < Number.MAX_VALUE) {
            oldGeom = tstBlck.geometry;
            tstBlck.geometry = this.rotateArray(tstBlck.geometry);
            tstVal = Math.min(tstVal, this.testRotateCW(tstBrd, tstBlck, depth));
            tstBlck.geometry = oldGeom;
          }
          if (tstVal < minVal) {
            minVal = tstVal;
            bestMove = 4;
          }
        }
      }
      return [bestMove, minVal];
    };

    TetrisAI.prototype.testRotateCCW = function(board, block, depth) {
      var minVal, oldCol, oldGeom;
      oldGeom = block.geometry;
      oldCol = block.column;
      minVal = Number.MAX_VALUE;
      block.geometry = this.rotateArray(this.rotateArray(this.rotateArray(block.geometry)));
      if (!this.blockIntersects(board, block, block.row, block.column)) {
        minVal = this.scoreMove(board, block, depth);
        minVal = Math.min(minVal, this.testMoveRight(board, block, depth));
        block.column = oldCol;
        minVal = Math.min(minVal, this.testMoveLeft(board, block, depth));
      }
      block.column = oldCol;
      block.geometry = oldGeom;
      return minVal;
    };

    TetrisAI.prototype.testRotateCW = function(board, block, depth) {
      var minVal, oldCol, oldGeom;
      oldGeom = block.geometry;
      oldCol = block.column;
      minVal = Number.MAX_VALUE;
      block.geometry = this.rotateArray(block.geometry);
      if (!this.blockIntersects(board, block, block.row, block.column)) {
        minVal = this.scoreMove(board, block, depth);
        minVal = Math.min(minVal, this.testMoveRight(board, block, depth));
        block.column = oldCol;
        minVal = Math.min(minVal, this.testMoveLeft(board, block, depth));
      }
      block.column = oldCol;
      block.geometry = oldGeom;
      return minVal;
    };

    TetrisAI.prototype.testMoveLeft = function(board, block, depth) {
      var minVal;
      minVal = Number.MAX_VALUE;
      while (block.column > 0) {
        block.column -= 1;
        if (this.blockIntersects(board, block, block.row, block.column)) {
          break;
        }
        minVal = Math.min(minVal, this.scoreMove(board, block, depth));
      }
      return minVal;
    };

    TetrisAI.prototype.testMoveRight = function(board, block, depth) {
      var minVal;
      minVal = Number.MAX_VALUE;
      while (block.column + block.geometry[0].length < board[0].length) {
        block.column += 1;
        if (this.blockIntersects(board, block, block.row, block.column)) {
          break;
        }
        minVal = Math.min(minVal, this.scoreMove(board, block, depth));
      }
      return minVal;
    };

    TetrisAI.prototype.rotateArray = function(theArray) {
      var column, outArray, row, _i, _j, _ref, _ref1;
      outArray = [];
      for (row = _i = 0, _ref = theArray.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = theArray[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (row === 0) {
            outArray[column] = [];
          }
          outArray[column][row] = theArray[theArray.length - row - 1][column];
        }
      }
      return outArray;
    };

    TetrisAI.prototype.cloneBoard = function(board) {
      var column, out, row, _i, _j, _ref, _ref1;
      out = [];
      for (row = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        out[row] = [];
        for (column = _j = 0, _ref1 = board[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          out[row][column] = board[row][column].isFull;
        }
      }
      return out;
    };

    TetrisAI.prototype.cloneBlock = function(block) {
      var column, out, row, _i, _j, _ref, _ref1;
      out = {
        row: Math.max(0, block.row),
        column: block.column,
        geometry: null
      };
      out.geometry = [];
      for (row = _i = 0, _ref = block.geometry.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        out.geometry[row] = [];
        for (column = _j = 0, _ref1 = block.geometry[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          out.geometry[row][column] = block.geometry[row][column] === 1;
        }
      }
      return out;
    };

    TetrisAI.prototype.scoreMove = function(currentBoard, block, depth) {
      var boardId, item, nextBoard, piece, row, rowProduct, score, _i, _j, _k, _len, _len1, _len2, _ref;
      if (depth >= this.maxDepth) {
        return this.evaluate(this.testDrop(currentBoard, block));
      }
      nextBoard = this.testDrop(currentBoard, block);
      boardId = "";
      if (depth === 0) {
        for (_i = 0, _len = nextBoard.length; _i < _len; _i++) {
          row = nextBoard[_i];
          rowProduct = 0;
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            item = row[_j];
            rowProduct *= 2;
            if (item) {
              rowProduct += 1;
            }
          }
          if (boardId.length > 0) {
            boardId += "|" + rowProduct;
          } else if (rowProduct > 0) {
            boardId += rowProduct;
          }
        }
        if (this.moveCache.hasOwnProperty(boardId)) {
          return this.moveCache[boardId];
        }
      }
      score = Number.MIN_VALUE;
      _ref = this.pieces;
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        piece = _ref[_k];
        score = Math.max(score, this.calcMove(nextBoard, piece, depth + 1)[1]);
      }
      if (depth === 0) {
        this.moveCache[boardId] = score;
      }
      return score;
    };

    TetrisAI.prototype.testDrop = function(currentBoard, block) {
      var column, delta, out, row, shapeColumn, shapeRow, _base, _i, _j, _k, _l, _name, _ref, _ref1, _ref2, _ref3;
      delta = 0;
      while (!this.blockIntersects(currentBoard, block, block.row + delta + 1, block.column)) {
        ++delta;
      }
      out = [];
      for (row = _i = 0, _ref = currentBoard.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        out[row] = [];
        for (column = _j = 0, _ref1 = currentBoard[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          out[row][column] = currentBoard[row][column];
        }
      }
      for (shapeRow = _k = 0, _ref2 = block.geometry.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; shapeRow = 0 <= _ref2 ? ++_k : --_k) {
        for (shapeColumn = _l = 0, _ref3 = block.geometry[shapeRow].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; shapeColumn = 0 <= _ref3 ? ++_l : --_l) {
          (_base = out[shapeRow + block.row + delta])[_name = shapeColumn + block.column] || (_base[_name] = block.geometry[shapeRow][shapeColumn]);
        }
      }
      this.checkLines(out);
      return out;
    };

    TetrisAI.prototype.blockIntersects = function(board, block, row, column) {
      var shapeColumn, shapeRow, _i, _j, _ref, _ref1;
      for (shapeRow = _i = 0, _ref = block.geometry.length; 0 <= _ref ? _i < _ref : _i > _ref; shapeRow = 0 <= _ref ? ++_i : --_i) {
        if (row + shapeRow < 0 || row + shapeRow >= board.length) {
          return true;
        }
        for (shapeColumn = _j = 0, _ref1 = block.geometry[shapeRow].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; shapeColumn = 0 <= _ref1 ? ++_j : --_j) {
          if (column + shapeColumn < 0 || column + shapeColumn >= board[0].length) {
            return true;
          }
          if (block.geometry[shapeRow][shapeColumn] && board[row + shapeRow][column + shapeColumn]) {
            return true;
          }
        }
      }
      return false;
    };

    TetrisAI.prototype.evaluate = function(board) {
      var column, pipeLen, pipeRow, row, rowDepth, score, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      score = 0;
      for (row = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (column = _j = 0, _ref1 = board[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          if (board[row][column]) {
            score += (board.length - row + 2) / 2 * this.calcColumnMultiplier(column, board[row].length);
            if (row < board.length - 3) {
              score += (board.length - row + 6) / 8;
            }
          } else if (row > 0 && board[row - 1][column]) {
            score += 18;
            for (rowDepth = _k = row, _ref2 = board.length; row <= _ref2 ? _k < _ref2 : _k > _ref2; rowDepth = row <= _ref2 ? ++_k : --_k) {
              if (!board[rowDepth][column]) {
                score += 1;
              } else {
                break;
              }
            }
          }
        }
      }
      for (column = _l = 0, _ref3 = board[0].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; column = 0 <= _ref3 ? ++_l : --_l) {
        pipeLen = 0;
        pipeRow = -1;
        for (row = _m = 0, _ref4 = board.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; row = 0 <= _ref4 ? ++_m : --_m) {
          if (!board[row][column] && (column === 0 || board[row][column - 1]) && (column === board[0].length - 1 || board[row][column + 1])) {
            if (pipeRow === -1) {
              pipeRow = row;
            }
            ++pipeLen;
          }
        }
        if (pipeLen > 1) {
          score += pipeLen * (board.length - pipeRow + 3) / 4;
        }
      }
      return score;
    };

    TetrisAI.prototype.calcColumnMultiplier = function(column, len) {
      var val;
      val = ((column > len / 2 ? len - column - 1 : column) + 2) / (len + 2);
      return (val + 2) / 2.0;
    };

    TetrisAI.prototype.checkLines = function(board) {
      var row, _i, _ref;
      for (row = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        if (this.arrayIsFull(board[row])) {
          this.removeRow(board, row);
        }
      }
    };

    TetrisAI.prototype.arrayIsFull = function(theArray) {
      var filled, _i, _len;
      for (_i = 0, _len = theArray.length; _i < _len; _i++) {
        filled = theArray[_i];
        if (!filled) {
          return false;
        }
      }
      return true;
    };

    TetrisAI.prototype.removeRow = function(board, row) {
      var column, _i, _ref;
      board.splice(row, 1);
      board.splice(0, 0, []);
      for (column = _i = 0, _ref = board[1].length; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
        board[0][column] = false;
      }
    };

    return TetrisAI;

  })();

  window.TetrisAI = TetrisAI;

}).call(this);
